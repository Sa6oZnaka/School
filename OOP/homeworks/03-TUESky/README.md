#  TUESky – търсене на полети

В това домашно ще имплементираме базовия код на приложението TUESky, бъдещ конкурент на SkyScanner. Това ще включва класове за полети, комбинация от тях, както и интерфейс за търсенето им по различни критерии.

## Базов проект

В базовия проект има „скелет“ на приложението, който се състои от интерфейсите в пакета `org.elsys.tuesky.api`.

### `org.elsys.tuesky.api.trips`

В подпакета `trips` е моделът на представяне на полети и комбинацията от тях.

`Trip` представлява пътуването, което може да се състои от поредица полети (`Flight`) и престои (`Layover`). Двата интерфейса наследяват от `TripUnit`. Той предоставя един общ метод – за времетране (`getDuration`).

Създаването на пътуване става чрез т.нар. „builder pattern“.
Създаваме инстанция на `TripBuilder`. След това с няколко поредни извиквания на метода `then`, който връща `TripBuilder`, се комбинират престои и полети. `then` типично, но незадължително връща същата инстанция (т.е. `this`), върху която е извикана. Накрая се завършва с извикване на метода `end`, който вече връща инстанция на `Trip`.

`Trip` предоставя различни методи за вземане на обща продължителност, продължителност на престоите, брой на полетите и други.

### `org.elsys.tuesky.api.planner`

Класът `Planner` ще съдържа пътувания (вече комбинирани полети и престои) и ще предоставя методи за търсене. Търсенето става чрез подаване на на инстанции на интерфейса `TripQuery`. Видовете заявки биват за изходна точка, дестинация, продължителност, продължителност на престоя и брой полети. В следващата част е описано как се създават.

Заявките могат да се комбинират чрез методите `and` и `or`, а чрез метода `not` може заявката да се „инвертира“. Трите метода се извикват върху инстанция на `TripQuery` и връщат отново инстанция на `TripQuery`, която може да бъде както нов обект, така и същия.

### `org.elsys.tuesky.impl`

В този пакет и негови подпакети трябва да се намира вашата имплементация. В пакета в момента има два класа – `Factory` и `Trips`.

`Factory` предоставя методи за създаване на инстанции на `TripBuilder`, `Flight`, `Layover` и `Planner`.

В `Trips` има методи за създаване на инстанции на `TripQuery`.
Видовете заявки и методите, с които се създават, са:

* за изходна точка – `Trips::withOrigin`
* за дестинация – `Trips::withDestination`
* за междинна спирка – `Trips::via`
* за максимална продължителност – `Trips::withMaxDuration`
* за максимален престой – `Trips::withMaxLayoverDuration`
* за максимален брой полети – `Trips::withMaxFlights`

В папката `test`, където се намират тестовете, всички те са в този пакет. В базовия проект има тестове на класовете `Flight` и `Trip`, но трябва да се добавят тестове и за `Planner` в класа `PlannerTest`, който е празен.

## Примери

За да създадем пътуване от София до Атина, бихме могли да направим следното:

```java
Factory.startTrip()
       .then(Factory.createFlight("Sofia", "Athens", Duration.ofHours(1)))
       .end()
```

Пътуване от София до Ханиа през Атина:

```java
Factory.startTrip()
       .then(Factory.createFlight("Sofia", "Athens", Duration.ofHours(1)))
       .then(Factory.createLayover(Duration.ofMinutes(90)))
       .then(Factory.createFlight("Athens", "Xania", Duration.ofHours(1)))
       .end();
```

За да търсим пътувания от София до Атина, бихме могли да направим следното:
```java
planner.search(Trips.withOrigin("Sofia")
                    .and(Trips.withDestination("Athens")));
```

За да търсим пък полети от София до Атина или Барселона, ще напишем следното:
```java
planner.search(Trips.withOrigin("Sofia")
                    .and(Trips.withDestination("Athens")
                              .or(Trips.withDestination("Barcelona"))));

```

За да търсим полети от София, които не са до Атина:
```java
planner.search(Trips.withOrigin("Sofia")
                    .and(Trips.withDestination("Athens").not()));
```

## Бележки

1. В текущите класове не трябва да променяте сигнатурата на който и да е от методите, за да минават тестовете ви.

2. Методите на `Planner` не бива да променят обекта.

3. Елементите в `Planner` трябва да имплементират интерфейса `Trip`.

4. Методите в `Trips` връщат обекти, които наследяват 
(имплементират) `TripQuery`. Не e важно какви обекти връщат трите метода 
(може да бъде един и същ, или пък различни), важното е обектите да 
имплементират `TripQuery`.

5. Нестатичните методи, дефинирани в `TripQuery`, могат да връщат също различни 
типове обекти по ваша преценка, отново с единственото условие да 
имплементират `TripQuery`.

6. Това всъщност важи за всички методи, които връщат интерфейс.

7. Във вашия клас, имплементиращ `Trip`, имплементирайте `hashCode` и `equals`.

8. Когато не знаете откъде да започнете, започнете откъдето и да е. Решението 
накрая винаги ще излезе - стига изобщо да се захванете с проблема.

9. Питайте. :-)

## Оценяване

   *   Създаването на инстанции на `Trip` работи коректно - 1 т.
   *   `Planner::search` (и останалите методи в `Planner`) работят коректно с всички заявки без такива, които търсят за пътуване с конкретна междинна спирка. - 1 т.
   *   `Planner::search` (и останалите методи в `Planner`) работят коректно със заявки за междинна спирка. - 1 т.
   *   `TripQuery::not`, `TripQuery:and` и `TripQuery::or` работят коректно - 1 т.
   *   Има unit тестове за предишните три точки - 0.5 т.
   *   Методите в `Trip` са с константна сложност - 0.5 т.
   *   Всички класове в имплементацията (без имплементацията на `TripBuilder`) са immutable - 0.5 т.
   *   Качество на кода - 0.5 т.

## Срок

Крайният срок за предаване на домашното в мудъл е 12.05.2019 20:00. Архивирайте целия си проект в zip или tar.gz формат.